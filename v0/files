// middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/admin') || request.nextUrl.pathname.startsWith('/api/admin')) {
    const authHeader = request.headers.get('authorization')

    if (!authHeader) {
      return new NextResponse('認証が必要です', {
        status: 401,
        headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' }
      })
    }

    const credentials = authHeader.split(' ')[1]
    if (!credentials) {
      return new NextResponse('認証情報が不正です', {
        status: 401,
        headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' }
      })
    }

    const [username, password] = atob(credentials).split(':')

    if (username !== (process.env.ADMIN_USERNAME || process.env.NEXT_PUBLIC_ADMIN_USERNAME) ||
        password !== (process.env.ADMIN_PASSWORD || process.env.NEXT_PUBLIC_ADMIN_PASSWORD)) {
      return new NextResponse('認証に失敗しました', {
        status: 401,
        headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' }
      })
    }
  }

  return NextResponse.next()
}

export const config = { matcher: ['/admin/:path*', '/api/admin/:path*'] }

// app/api/admin/bootstrap/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { bootstrapSchema } from '@/lib/db/bootstrap'

function checkAuth(request: NextRequest) {
  const auth = request.headers.get('authorization')
  if (!auth) return false
  const token = auth.split(' ')[1]
  if (!token) return false
  const [user, pass] = atob(token).split(':')

  const ADMIN_USER = process.env.ADMIN_USERNAME || process.env.NEXT_PUBLIC_ADMIN_USERNAME || 'unionadmin'
  const ADMIN_PASS = process.env.ADMIN_PASSWORD || process.env.NEXT_PUBLIC_ADMIN_PASSWORD || 'admin123'
  return user === ADMIN_USER && pass === ADMIN_PASS
}

export async function POST(request: NextRequest) {
  if (!checkAuth(request)) {
    return NextResponse.json(
      { error: { code: 'unauthorized', message: '認証に失敗しました' } },
      { status: 401, headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' } }
    )
  }

  try {
    await bootstrapSchema()
    return NextResponse.json({ ok: true, note: 'スキーマ初期化が完了しました。5-10秒後に再読込してください。' })
  } catch (e: any) {
    const message = String(e?.message || e)

    if (/requested path is invalid/i.test(message) || /invalid_path/.test(e?.code)) {
      return NextResponse.json(
        {
          error: {
            code: 'bad_request',
            message: 'リクエストされたパスが不正です',
            details: 'SUPABASE_URL は https://{ref}.supabase.co（パスなし）を設定してください。/rest/v1 は不要です。'
          }
        },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: { code: 'internal_server_error', message: 'サーバー内部でエラーが発生しました' } },
      { status: 500 }
    )
  }
}

// components/db-setup-callout.tsx
import { useState } from 'react'
import { Button } from 'antd'
import { useSupabaseClient } from '@supabase/auth-helpers-react'

const DbSetupCallout = () => {
  const [loading, setLoading] = useState(false)
  const supabase = useSupabaseClient()

  const runSetup = async () => {
    setLoading(true)
    const { data, error } = await supabase.from('setup').select('*')
    setLoading(false)

    if (error) {
      const res = await fetch('/api/admin/bootstrap', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      })

      const data = await res.json().catch(() => ({}))
      if (!res.ok) {
        const code = data?.error?.code
        const msg: string = data?.error?.message || ''
        if (code === 'bad_request' && (/path/i.test(msg) || msg.includes('パス'))) {
          throw new Error('Supabase の URL 設定が不正です。/setup の手順に従って修正してください。')
        }
        throw new Error(msg || '初期化に失敗しました')
      }
    }
  }

  return (
    <div>
      <Button onClick={runSetup} loading={loading}>
        Setup Database
      </Button>
    </div>
  )
}

export default DbSetupCallout

// app/api/admin/projects/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getProjects } from '@/lib/db/projects'

function checkAuth(request: NextRequest) {
  const auth = request.headers.get('authorization')
  if (!auth) return false
  const token = auth.split(' ')[1]
  if (!token) return false
  const [user, pass] = atob(token).split(':')

  const ADMIN_USER = process.env.ADMIN_USERNAME || process.env.NEXT_PUBLIC_ADMIN_USERNAME || 'unionadmin'
  const ADMIN_PASS = process.env.ADMIN_PASSWORD || process.env.NEXT_PUBLIC_ADMIN_PASSWORD || 'admin123'
  return user === ADMIN_USER && pass === ADMIN_PASS
}

export async function GET(request: NextRequest) {
  if (!checkAuth(request)) {
    return NextResponse.json(
      { error: '認証に失敗しました' },
      { status: 401, headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' } }
    )
  }

  const projects = await getProjects()
  return NextResponse.json(projects)
}

// app/api/admin/projects/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getProjectById } from '@/lib/db/projects'

function checkAuth(request: NextRequest) {
  const auth = request.headers.get('authorization')
  if (!auth) return false
  const token = auth.split(' ')[1]
  if (!token) return false
  const [user, pass] = atob(token).split(':')

  const ADMIN_USER = process.env.ADMIN_USERNAME || process.env.NEXT_PUBLIC_ADMIN_USERNAME || 'unionadmin'
  const ADMIN_PASS = process.env.ADMIN_PASSWORD || process.env.NEXT_PUBLIC_ADMIN_PASSWORD || 'admin123'
  return user === ADMIN_USER && pass === ADMIN_PASS
}

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  if (!checkAuth(request)) {
    return NextResponse.json(
      { error: '認証に失敗しました' },
      { status: 401, headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' } }
    )
  }

  const project = await getProjectById(params.id)
  return NextResponse.json(project)
}

// app/api/admin/applications/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getApplications } from '@/lib/db/applications'

function checkAuth(request: NextRequest) {
  const auth = request.headers.get('authorization')
  if (!auth) return false
  const token = auth.split(' ')[1]
  if (!token) return false
  const [user, pass] = atob(token).split(':')

  const ADMIN_USER = process.env.ADMIN_USERNAME || process.env.NEXT_PUBLIC_ADMIN_USERNAME || 'unionadmin'
  const ADMIN_PASS = process.env.ADMIN_PASSWORD || process.env.NEXT_PUBLIC_ADMIN_PASSWORD || 'admin123'
  return user === ADMIN_USER && pass === ADMIN_PASS
}

export async function GET(request: NextRequest) {
  if (!checkAuth(request)) {
    return NextResponse.json(
      { error: '認証に失敗しました' },
      { status: 401, headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' } }
    )
  }

  const applications = await getApplications()
  return NextResponse.json(applications)
}

// app/api/admin/diag/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getDiag } from '@/lib/db/diag'

function checkAuth(request: NextRequest) {
  const auth = request.headers.get('authorization')
  if (!auth) return false
  const token = auth.split(' ')[1]
  if (!token) return false
  const [user, pass] = atob(token).split(':')

  const ADMIN_USER = process.env.ADMIN_USERNAME || process.env.NEXT_PUBLIC_ADMIN_USERNAME || 'unionadmin'
  const ADMIN_PASS = process.env.ADMIN_PASSWORD || process.env.NEXT_PUBLIC_ADMIN_PASSWORD || 'admin123'
  return user === ADMIN_USER && pass === ADMIN_PASS
}

export async function GET(request: NextRequest) {
  if (!checkAuth(request)) {
    return NextResponse.json(
      { error: '認証に失敗しました' },
      { status: 401, headers: { 'WWW-Authenticate': 'Basic realm="Admin Area"' } }
    )
  }

  const diag = await getDiag()
  return NextResponse.json(diag)
}
